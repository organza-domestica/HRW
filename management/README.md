# Management MVP - GitHub Runner + App Workload initialization (RG+VNet)

Folder `management` stanowi kod infrastruktury dotyczący powołania obiektów potrzebnych do utrzymania infrastruktury.
W skład "deploymentu" wchodzą następujące moduły:

- rg, Resource Group - definicja typowej grupy zasobów,
- vnet, Virtual Netowrk - definicja typowej sieci wirtualnej. Definiuje ją nazwa, grupa zasobów, lokacja, podsieć oraz używane serwery DNS.
- ghr, GitHub Runner - VM na Oracle Linux 8, z paczkami: `jq`, `node`, `docker`, `github-runner`.

Powyższe, spięte jest definicją `main.tf` obok tego pliku `README.md`. W ramach definicji wystawiana jest grupą zasobów dla `GitHub Runner` jak również pod workload aplikacji `HRW`. W obu grupach tworzone są sieci, które są ze sobą "peerowane".


## Github Runner
- Rejestruje się w repo HRW.
- Wymaga skonfigurowanego [PAT](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) z uprawnieniami podpinania Runnerów do repo.
- "Provisioning" odbywa się za pomocą "Terraform" + "Cloud-Init" (`modules/ghr/cloud-init.txt`)

Ważne:
- Zakończenie procesu Terraform, nie jest równoznaczne z zakończeniem procesu Cloud-Init. Dlatego też od momentu zakończenie działania Terraform do rejestracji GitHub Runnera w repo na GitHub może upłynąć nawet paręnaście minut (szczególnie gdy włączony jest auto update Linux przy wystawianiu, patrz plik `modules/ghr/cloud-init.txt`)
- Runner nie zarejestruje się w repo na GitHub, jeśli istnieje już obiekt runnera o takiej samej nazwie, nawet w trybie offline.

## Personal Authentication Token (PAT)
Aby GitHub Runner mógł rejestrować się w repo na GitHub, wymaga utworzenia PAT. Wymagane uprawnienia przy kreowaniu PAT (classic):
- repo (all)
- admin:org (all) (mandatory for organization-wide runner)
- admin:public_key - read:public_key
- admin:repo_hook - read:repo_hook
- admin:org_hook
- notifications
- workflow

## Quick Start

- Dostosuj konfigurację w pliku ze zmiennymi Terraform dla właściwej subskrypcji np.: `subscriptions/devtest/vars.tfvars`
- Autoryzacja Terraform, dwie metody:
  1. Service Principal
  ```
  export ARM_CLIENT_ID="051142da-b665-4302-a159-63083619779e"
  export ARM_CLIENT_SECRET="<<service principle password>>"
  export ARM_SUBSCRIPTION_ID="4ef574f8-b048-4d20-ac39-c25393983ea1"
  export ARM_TENANT_ID="5c31e633-3f56-44e3-89d7-1ada903ce696"
  ```
  2. lub az login
  `az login`
- Zmienne środowiskowe
  ```
  export TF_VAR_environment=dev
  export TF_VAR_sql_administrator_login=sqladmin
  export STORAGE_ACCOUNT=azlxsttfhrwdevtest       # existing Storage Account
  export CONTAINER_NAME=tfstate-ghrunner          # container for mgmt terrform process
  export TF_KEY=az-lx-hrw-dev.tfstate-ghrunner
  export RESOURCE_GROUP=az-lx-rg-tf-hrw-devtest
  ```
- Inicjalizacja terraform
  `terraform init --backend-config="storage_account_name=$STORAGE_ACCOUNT" --backend-config="container_name=$CONTAINER_NAME" --backend-config="resource_group_name=$RESOURCE_GROUP" --backend-config="key=$TF_KEY"`
- Plan
  `terraform plan -out ghrunners.tfplan  -var-file=subscriptions/devtest/vars.tfvars`
- Apply
  `terraform apply ghrunners.tfplan`

## Utrzymanie
### GitHub Runner
Docelowo GitHub Runnery będą [efemeryczne](https://docs.github.com/en/actions/hosting-your-own-runners/autoscaling-with-self-hosted-runners#using-ephemeral-runners-for-autoscaling), co zdejmie obowiązek patchowania ów systemów. Na ten moment zachowanie to, można symulować poprzez niszczenie GitHub Runnera (zamiast patchowania) i powoływanie go w momentach kiedy będzie chciało się dokonać zmian na infrastrukturze.

#### Usuwanie
```
# usunięcie obiektu VM i jej dysku
az vm ...

# usuniecie terraform state
terraform state list
terraform state rm 'module.ghr.azurerm_linux_virtual_machine.vm_gh_runner'
```
#### Dodawanie
ponowny `plan` i `apply` jak w "Quick Start"

### Środowiska
Konfiguracja środowisk znajduje się w zmiennej Terraform o nazwie "environments". Obecnie parametryzowana jest przez nazwę środowiska oraz podsieć dla niej przeznaczoną. Dodawanie/usuwanie środowisk odbywa się poprzez aktualizację listy w tej zmiennej oraz uruchomienie `plan` i `apply` jak w "Quick Start". Przykład konfiguracji środowisk "dev", "dev2" oraz "test" via `subscriptions/devtest/vars.tfvars`:
```
environments = [
    {
      env_name = "dev"
      vnet_address_prefix = "10.172.16.0/24"
    },
    {
      env_name = "dev2"
      vnet_address_prefix = "10.174.16.0/24"
    },
    {
      env_name = "test"
      vnet_address_prefix = "10.172.13.0/24"
    }
]
```
# Autogenerated docs:
Aktualizacja poniższych tabel:
`terraform-docs markdown table . --output-file=README.md`

<!-- BEGIN_TF_DOCS -->
## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_terraform"></a> [terraform](#requirement\_terraform) | >=0.12 |
| <a name="requirement_azurerm"></a> [azurerm](#requirement\_azurerm) | =3.24.0 |
| <a name="requirement_random"></a> [random](#requirement\_random) | ~>3.0 |
| <a name="requirement_tls"></a> [tls](#requirement\_tls) | ~>4.0 |

## Providers

| Name | Version |
|------|---------|
| <a name="provider_azurerm"></a> [azurerm](#provider\_azurerm) | 2.99.0 |

## Modules

| Name | Source | Version |
|------|--------|---------|
| <a name="module_ghr"></a> [ghr](#module\_ghr) | ./modules/ghr | n/a |
| <a name="module_ghrrg"></a> [ghrrg](#module\_ghrrg) | ./modules/rg | n/a |
| <a name="module_ghrvnet"></a> [ghrvnet](#module\_ghrvnet) | ./modules/vnet | n/a |
| <a name="module_hrwrg"></a> [hrwrg](#module\_hrwrg) | ./modules/rg | n/a |
| <a name="module_hrwvnet"></a> [hrwvnet](#module\_hrwvnet) | ./modules/vnet | n/a |

## Resources

| Name | Type |
|------|------|
| [azurerm_virtual_network_peering.ghrpeer](https://registry.terraform.io/providers/hashicorp/azurerm/3.24.0/docs/resources/virtual_network_peering) | resource |
| [azurerm_virtual_network_peering.hrwpeer](https://registry.terraform.io/providers/hashicorp/azurerm/3.24.0/docs/resources/virtual_network_peering) | resource |

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_env"></a> [env](#input\_env) | Name of environment to deploy workload Resource Group to | `string` | `"dev"` | no |
| <a name="input_gh_pat"></a> [gh\_pat](#input\_gh\_pat) | Personal Authentication Token used for registering GitHub Runners | `string` | `""` | no |
| <a name="input_gh_runners_subnet_address_prefix"></a> [gh\_runners\_subnet\_address\_prefix](#input\_gh\_runners\_subnet\_address\_prefix) | n/a | `string` | `"10.173.16.48/28"` | no |
| <a name="input_ghr_vnet_address_prefix"></a> [ghr\_vnet\_address\_prefix](#input\_ghr\_vnet\_address\_prefix) | CICD assigned to given subscription | `string` | `"10.173.16.0/24"` | no |
| <a name="input_resource_group_location"></a> [resource\_group\_location](#input\_resource\_group\_location) | Location for created resource groups | `string` | `"westeurope"` | no |
| <a name="input_subscription_env"></a> [subscription\_env](#input\_subscription\_env) | Subscription to deploy GitHub Runner to | `string` | `"devtest"` | no |
| <a name="input_vnet_address_prefix"></a> [vnet\_address\_prefix](#input\_vnet\_address\_prefix) | CICD assigned to given subscription | `string` | `"10.172.16.0/24"` | no |
| <a name="input_vnet_dns_servers"></a> [vnet\_dns\_servers](#input\_vnet\_dns\_servers) | Set DNS servers for subscription. Uses Public DNS if empty array | `list(string)` | `[]` | no |

## Outputs

| Name | Description |
|------|-------------|
| <a name="output_public_ip_address"></a> [public\_ip\_address](#output\_public\_ip\_address) | n/a |
| <a name="output_tls_private_key"></a> [tls\_private\_key](#output\_tls\_private\_key) | n/a |
<!-- END_TF_DOCS -->
